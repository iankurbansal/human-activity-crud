package com.ha.crud.controller;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.ha.crud.entity.SensorData;
import com.ha.crud.repo.SensorDataRepo;

@Controller    // This means that this class is a Controller
@RequestMapping(path="/sensorData") // This means URL's start with /demo (after Application path)
public class SensorDataController {
	private static final Logger logger = LoggerFactory.getLogger(SensorDataController.class);

	// This means to get the bean called SensorDataRepo
	// Which is auto-generated by Spring, we will use it to handle the data
	@Autowired 
	private SensorDataRepo sensorDataRepo;


	@GetMapping(path="/all")
	public @ResponseBody Iterable<SensorData> getAllData() {
		logger.debug("get request to /all path made");
		return sensorDataRepo.findAll();
	}

	/*@GetMapping(path="/getDataForRange")
	public @ResponseBody Iterable<SensorData> getDataForPeriod(@RequestBody DateRange dateRange) {
		logger.debug("get request for period : "+dateRange);
		return sensorDataRepo.findDataForRange(dateRange);
	}*/

	@PostMapping(path="/addData")
	public @ResponseBody String addDataToDb(@RequestBody List<SensorData> sensorDataValues) {
		logger.debug("post request to /addData path made sensorData : "+sensorDataValues);
		sensorDataRepo.saveAll(sensorDataValues);
		return "{\" batch save success\"}";
	}

	@GetMapping(path="/getCsv")
	public @ResponseBody String getAllDataCsv(@RequestParam(required=false) String activity,@RequestParam(required=false) String subject,@RequestParam String type) {
		logger.debug("get request to /getCsv path made");
		if("rest".equals(type)) {
			return printCsv();
		}else {
			return printFile(activity, subject);
		}
	}

	@GetMapping(path="/deleteAll")
	public @ResponseBody String deleteAllData() {
		sensorDataRepo.deleteAll();
		return "Success";
	}
	private String printFile(String activity, String subject) {
		String fileName = "C:\\Users\\eankuba\\Desktop\\Activity\\"+activity+"_"+subject+".csv";
		Iterable<SensorData> allSD = sensorDataRepo.findAll();
		try {
			CSVPrinter csvPrinter = null;
			BufferedWriter writer = Files.newBufferedWriter(Paths.get(fileName));
			csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
					"tBodyAcc-mean()-X","tBodyAcc-mean()-Y","tBodyAcc-mean()-Z","tBodyAcc-max()-X","tBodyAcc-max()-Y"
					,"tBodyAcc-max()-Z","tBodyGyro-mean()-X","tBodyGyro-mean()-Y","tBodyGyro-mean()-Z",
					"subject","Activity"));

			List<SensorData> sensorDataList = new ArrayList<>();
			for(SensorData sd:allSD) {
				sensorDataList.add(sd);
			}
			Collections.sort(sensorDataList,new SortbyDate());
			Date batchDate = sensorDataList.get(0).getCreateTime();
			List<SensorData> sdBatch = new ArrayList<>();
			for(SensorData sd : sensorDataList) {
				long diff = sd.getCreateTime().getTime() - batchDate.getTime();
				long diffMinutes = diff / (1000);         
				if(diffMinutes<3) {
					sdBatch.add(sd);
				}else {
					Double xCoorMax=0d,yCoorMax=0d,zCoorMax=0d,xCoorMean,yCoorMean,zCoorMean,xAxisMean,yAxisMean,zAxisMean;
					Double xCoorSum=0d,yCoorSum=0d,zCoorSum=0d,xAxisSum=0d,yAxisSum=0d,zAxisSum=0d;
					int coorTotal=0,axisTotal=0;
					for(SensorData sd1: sdBatch) {
						if(xCoorMax<sd1.getxCoor()) {
							xCoorMax = sd1.getxCoor();
						}
						if(yCoorMax<sd1.getyCoor()) {
							yCoorMax = sd1.getyCoor();
						}
						if(zCoorMax<sd1.getzCoor()) {
							zCoorMax = sd1.getzCoor();
						}
						if(sd1.getxCoor()!=0) {
							coorTotal++;
							xCoorSum+=sd1.getxCoor();yCoorSum+=sd1.getyCoor();zCoorSum+=sd1.getzCoor();
						}
						if(sd1.getxAxis()!=0) {
							axisTotal++;
							xAxisSum+=sd1.getxAxis();yAxisSum+=sd1.getyAxis();zAxisSum+=sd1.getzAxis();
						}
					}
					xCoorMean=(Double)xCoorSum/coorTotal;yCoorMean=(Double)yCoorSum/coorTotal;zCoorMean=(Double)zCoorSum/coorTotal;
					xAxisMean=(Double)xAxisSum/axisTotal;yAxisMean=(Double)yAxisSum/axisTotal;zAxisMean=(Double)zAxisSum/axisTotal;
					if(coorTotal>0&&axisTotal>0)
						csvPrinter.printRecord(""+xCoorMean,""+yCoorMean,""+zCoorMean,""+xCoorMax,""+yCoorMax,""+zCoorMax,
								""+xAxisMean,""+yAxisMean,""+zAxisMean,subject,activity);

					// batch cleanup
					sdBatch.clear();
					sdBatch.add(sd);
					batchDate=sd.getCreateTime();
					xCoorSum=0d;yCoorSum=0d;zCoorSum=0d;xAxisSum=0d;yAxisSum=0d;zAxisSum=0d;
					coorTotal=0;axisTotal=0;
					xCoorMax=0d;yCoorMax=0d;zCoorMax=0d;
				}
			}
			writer.flush();
			csvPrinter.close();
		} catch (IOException e) {
			e.printStackTrace();
		}


		return "file write success";
	}

	
	private String printCsv() {
		Iterable<SensorData> allSD = sensorDataRepo.findAll();
		try {
			CSVPrinter csvPrinter = null;
		    StringWriter sw = new StringWriter();
			csvPrinter = new CSVPrinter(sw, CSVFormat.DEFAULT.withHeader(
					"tBodyAcc.mean...X","tBodyAcc.mean...Y","tBodyAcc.mean...Z","tBodyAcc.max...X","tBodyAcc.max...Y"
					,"tBodyAcc.max...Z","tBodyGyro.mean...X","tBodyGyro.mean...Y","tBodyGyro.mean...Z"));

			List<SensorData> sensorDataList = new ArrayList<>();
			for(SensorData sd:allSD) {
				sensorDataList.add(sd);
			}
			if(sensorDataList.isEmpty()) {
				csvPrinter.close();
				sw.flush();
				return "";
			}
			Collections.sort(sensorDataList,new SortbyDate());
			Date batchDate = sensorDataList.get(0).getCreateTime();
			List<SensorData> sdBatch = new ArrayList<>();
			for(SensorData sd : sensorDataList) {
				long diff = sd.getCreateTime().getTime() - batchDate.getTime();
				long diffMinutes = diff / (1000);         
				if(diffMinutes<3) {
					sdBatch.add(sd);
				}else {
					Double xCoorMax=0d,yCoorMax=0d,zCoorMax=0d,xCoorMean,yCoorMean,zCoorMean,xAxisMean,yAxisMean,zAxisMean;
					Double xCoorSum=0d,yCoorSum=0d,zCoorSum=0d,xAxisSum=0d,yAxisSum=0d,zAxisSum=0d;
					int coorTotal=0,axisTotal=0;
					for(SensorData sd1: sdBatch) {
						if(xCoorMax<sd1.getxCoor()) {
							xCoorMax = sd1.getxCoor();
						}
						if(yCoorMax<sd1.getyCoor()) {
							yCoorMax = sd1.getyCoor();
						}
						if(zCoorMax<sd1.getzCoor()) {
							zCoorMax = sd1.getzCoor();
						}
						if(sd1.getxCoor()!=0) {
							coorTotal++;
							xCoorSum+=sd1.getxCoor();yCoorSum+=sd1.getyCoor();zCoorSum+=sd1.getzCoor();
						}
						if(sd1.getxAxis()!=0) {
							axisTotal++;
							xAxisSum+=sd1.getxAxis();yAxisSum+=sd1.getyAxis();zAxisSum+=sd1.getzAxis();
						}
					}
					xCoorMean=(Double)xCoorSum/coorTotal;yCoorMean=(Double)yCoorSum/coorTotal;zCoorMean=(Double)zCoorSum/coorTotal;
					xAxisMean=(Double)xAxisSum/axisTotal;yAxisMean=(Double)yAxisSum/axisTotal;zAxisMean=(Double)zAxisSum/axisTotal;
					if(coorTotal>0&&axisTotal>0)
						csvPrinter.printRecord(""+xCoorMean,""+yCoorMean,""+zCoorMean,""+xCoorMax,""+yCoorMax,""+zCoorMax,
								""+xAxisMean,""+yAxisMean,""+zAxisMean);

					// batch cleanup
					break;
				}
			}
			sw.flush();
			csvPrinter.close();
			return sw.toString();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return "failed";
	}
	
	
	
	class SortbyDate implements Comparator<SensorData> 
	{ 
		public int compare(SensorData a, SensorData b) 
		{ 
			return a.getCreateTime().compareTo(b.getCreateTime()); 
		} 
	} 
}